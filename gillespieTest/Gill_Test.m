close all
clear variables
%%GILLESPIE ALGORITHM TO GENERATE LONGER TIME SERIES DATA FOR CSA & DCSA
% AIM CHECK IF REL T IS CONVERGED FOR HIGH LAG T

% Specify the folder where the files live.
myFolder = 'C:\Users\Sarah\Documents\MATLAB\CONVERGENCE_POP\310_CSA_CG\lagtest';
% Check to make sure that folder actually exists.  Warn user if it doesn't.
if ~isdir(myFolder)
    errorMessage = sprintf('Error: The following folder does not exist:\n%s', myFolder);
    uiwait(warndlg(errorMessage));
    return;
end
ns = 2; % number of states
T = 310; %temp in Kelvin
peptide = 'CSA';

fin1 = fullfile(myFolder, '310_CSA_KM_0040.txt'); %read in rate matrix
K = load(fin1, '-ascii');

%fin2 = fullfile(myFolder, '310_CSA_KM_R_EVEC_0040.txt'); %read in Right Evector
%R = load(fin2, '-ascii');

%calculate equilibrium population probabilities from the 1st Right Evector
%Peq = zeros(ns,1); 

%    Peq(a,1) = R(a,1)./sum(R(:,1));
%end

fprintf('Section 2: Spectral decomposition (getting eigenvalues/vectors) and finding equilibrium probability vector')

%%
%calculate equilibrium from spectral decomposition
[eigvec,eigval]=eig(K); % diagonalize K, eigvec stores the eigenvectors, eigval the eigenvalues

display(eigval)

[dsorted,index]=sort(diag(eigval),'descend'); % sort the eigenvalues. dsorted stores the eigenvalues, index the corresponding indices
% sorted eigenvalues:
ind=index(1); %index corresponding to 0 eigenvalue
Peq=eigvec(:,ind)/sum(eigvec(:,ind)); % equilibrium probability corresponds to 0 eigenvalue. Based on the equilibrium probability we can also obtain the energy.

display(Peq)

% Plot of sorted eigenvalues
figure
hold on
x=linspace(1,ns,ns);
scatter(x,dsorted,'filled')
ylabel('Eigenvalue','FontSize',18)
%%fprintf('Section 4: Finding second right eigenvector')

% splitting and eigvec
[eigvec,eigval]=eig(K'); % diagonalize K, eigvec stores the right eigenvectors
[dsorted,index]=sort(diag(eigval),'descend'); % sort the eigenvalues. 

display(dsorted)

slowest_relrate=-dsorted(2);
slow_vec=eigvec(:,index(2));

figure
hold on
bar(slow_vec)
xlabel('# State','FontSize',18)
ylabel('Second eigenvector','FontSize',18)
hold off

%% Run Gillespie to obtain trajectories ..................................
for i=1:ns
  for j=1:ns
    if ( i ~= j ) % i =\= j 
       p(j,i)=K(j,i)/(-K(i,i));
    end
  end
end

for j=1:ns
pp(1,j)=0;
for i=1:ns
  pp(i+1,j)=sum(p(1:i,j)); % The pp matrix stores cumulative transition probabilities
end
end

s=1; %starting state
time=0; 
tcum=zeros(ns,1); % creates a vector of N elements
%tstep = 500e-12; %timestep from simulation

NN=50000; % Number of transitions
for k=1:NN
        tadd=(1/K(s,s))*log(rand); %*tstep; % tadd is the survival time the system stays in state s. 
        %It is calculated based on a single exponential decay for the survival time.
        time=time+tadd; %time=total time
        t_traj(k)=time; %t_traj matrix saves information about the survival times
        s_traj(k)=s;    %s_traj matrix saves information about the current state
        
        ss=find(histc(rand,pp(:,s))); % finds the new state
        tcum(s)=tcum(s)+tadd; % total time that the system spends in state s
        s=ss; %the new state is ss
end

file_name1 = sprintf('%d_%s_G_TRAJ.txt',T,peptide);
dlmwrite(file_name1, s_traj, 'delimiter', '\t');

file_name2 = sprintf('%d_%s_Time_TRAJ.txt',T,peptide);
dlmwrite(file_name2, t_traj, 'delimiter', '\t');
measured_Peq=tcum/sum(tcum); 
%%
%average time spent in each state / total time = measured euqilibrium probability (p_eq)
fprintf('Comparing the true eigenvector to the trajectories estimate')
display(Peq)
display(measured_Peq)

%% Compare analytical and measured p_eq
figure
hold on
xlabel('# State','FontSize',18)                   
ylabel('Equilibrium probability','FontSize',18)
bar(Peq,'r')
bar(measured_Peq,'b', 'BarWidth',0.4)
legend('simulation','estimated')
%% 

fprintf('Viewing the trajectory generated by the Gillespie algorithm')
bins=100;
tim=linspace(0,t_traj(end),NN*bins); % We discretize the time
ind=1;

for i=1:NN*bins % we have NN transitions and we have divided the timescale in 100*NN steps
   while tim(i) > t_traj(ind)
      ind=ind+1;
   end
   state(i)=s_traj(ind);
end

% Plot of trajectory
figure
hold on
%plot(state(1:500e-12)) % We plot the whole trajectory. Lets zoom in!!!
xlabel('time','FontSize',18)
title('Trajectory','FontSize',24)
ylabel('# State','FontSize',18)
hold off

figure
hold on
plot(state(1:15000 )) % 
%plot(state(NN-4999:NN),'r') % Uncoment to add more parts of the trajectory
xlabel('time','FontSize',18)
title('Trajectory - Zoom in!','FontSize',24)
ylabel('# State','FontSize',18)
hold off


%%
%% 

fprintf('Section 8: Comparison of autocorrelation function and slowest relaxation rate')

[ACF,lags,bounds] = autocorr(state,10000); 
% autocorrelation function of the state.Change the lagtime up to 10000
%autocorr(state,10000) %uncomment to see how the autocorrelation function looks. 

figure
plot(tim(1+lags),log(ACF),'LineWidth',2)
hold on
x=linspace(0,10,100);
plot(x,-slowest_relrate*x,'r-','LineWidth',2) 
% the mean of the log autocorrelation function is the second smaller eigenvalue
legend('autocorrelation function','slowest relaxation rate')
xlabel('Time','FontSize',18)
ylabel('ln(ACF)','FontSize',18)
